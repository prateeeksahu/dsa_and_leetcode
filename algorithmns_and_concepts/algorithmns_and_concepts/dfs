DFS (Depth First Search) is an algorithm used for traversing or searching tree or graph data structures. The core idea behind DFS is that it explores as far down a branchas possible before backtracking. This means DFS goes to the deepest node first, then the second deepest, and so on.

DFS and its Applications
DFS is commonly used in graphs and trees, but it can also be applied to scenarios where a tree-like structure is formed, often through recursion.

Adjacency List Representation
In DFS, we typically use an adjacency list to represent the graph or tree. An adjacency list is a way of representing which nodes are connected. Here’s an example for a graph represented as an adjacency list:

1: [2, 3]
2: [1, 4, 5]
3: [1, 6, 7]
4: [2]
5: [2]
6: [3]
7: [3]

This can be implemented either as:

A map where each node maps to a list of its neighbors.
An array of lists where the list at an index represents the node's neighbors.
Now, consider the following tree structure:

   1
  / \
 2   3
/ \ / \
4 5 6 7

How DFS Works on a Tree
Let’s see how DFS would work on this tree, starting from the root node 1:

Start at node 1 and go to its first child, 2.
From 2, go deeper to 4. Since 4 has no unvisited children, backtrack to 2.
From 2, now go to its second child, 5. Similarly, since 5 has no unvisited children, backtrack to 2, and then to 1.
Now, from 1, go to the second child, 3.
From 3, go deeper to 6. Since 6 has no unvisited children, backtrack to 3.
Finally, go to the second child of 3, which is 7. After visiting 7, the traversal is complete.
Visit Order in DFS
The visiting order of nodes in this tree using DFS would look like this:

1 -> 2 -> 4 -> 2 -> 5 -> 2 -> 1 -> 3 -> 6 -> 3 -> 7


What’s Happening?
DFS starts at the root (1 in this case) and explores as far down one branch as possible.
After reaching the deepest node (4), it backtracks to its parent (2) and explores other children (like 5).
Once all children of 2 are visited, DFS backtracks to 1 and repeats the process for node 3.
The pattern is: go down one branch until no further unvisited nodes remain, then backtrack and explore other branches.
DFS in Graphs
DFS works similarly in graphs. For instance, if we add another node 8 connected to both 5 and 6 in our tree, the structure becomes:

    1
   / \
  2   3
 / \ / \
4  5 6  7
   \ /
    8


Here, DFS can start from any node, not necessarily the root. The algorithm explores adjacent nodes, and we maintain a "visited" array to check whether a node has been visited already. This is crucial in graphs, as it helps avoid cycles—visiting a node again that has already been visited could trap the algorithm in an infinite loop.

When DFS encounters a node that’s already been visited, it simply returns, preventing the cycle.


code :

class Solution {
  
    public ArrayList<Integer> dfsOfGraph(int V, ArrayList<ArrayList<Integer>> adj) {
        int visited[]=new int [V];
        ArrayList<Integer> al=new ArrayList<>();
        al.add(0);
        dfs(0,adj,al,visited);
        return al;
    }
    
    public static void dfs(int s,ArrayList<ArrayList<Integer>> adj,ArrayList<Integer> al,int visit[]){
        visit[s]=1;
        for(Integer i: adj.get(s)){
            int j=(int )i;
            if(visit[j]==0){
                al.add(i);
                dfs(i,adj,al,visit);
            }
        }
    }
} 
